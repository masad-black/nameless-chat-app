generator client {
  provider = "prisma-client-js"
  output   = "../app/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Users {
  id           String   @id @default(uuid())
  username     String   @unique
  email        String   @unique
  password     String @default("12345678")
  bio          String   @default("Hey there.")
  profileImage String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  conversations       Conversations[]
  conversationMembers ConversationMembers[]
  messages            Messages[]
  groupRequests       GroupRequests[]

  @@index([email])
  @@index([username])
}

model Conversations {
  id          String  @id @default(uuid())
  createrId   String?  // Optional for direct chats, required for groups
  type        ConversationTypes
  name        String?  // Required for groups, null for direct
  bio         String?  // Required for groups, null for direct
  bannerImage String?  // Required for groups, null for direct
  isPublic    Boolean           @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user          Users?                @relation(fields: [createrId], references: [id], onDelete: SetNull)
  members       ConversationMembers[]
  messages      Messages[]
  groupRequests GroupRequests[]

  @@index([createrId])
  @@index([type])
  @@index([updatedAt]) // For sorting conversations by recent activity
}

enum ConversationTypes {
  direct
  group
}

model ConversationMembers {
  id       String            @id @default(uuid())
  role     ConversationRoles @default(member)
  joinedAt DateTime          @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  conversationId String
  conversation   Conversations @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  userId String
  user   Users  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId]) // Prevent duplicate memberships
  @@index([userId])
  @@index([conversationId])
}

enum ConversationRoles {
  member
  admin
}

model Messages {
  id       String       @id @default(uuid())
  type     MessageTypes @default(text)
  content  String
  imageUrl String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  conversationId String
  conversation   Conversations @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  senderId String
  sender   Users  @relation(fields: [senderId], references: [id])

  @@index([conversationId, createdAt]) // Optimized for fetching messages in order
  @@index([senderId])
}

enum MessageTypes {
  text
  image
}


model GroupRequests {
  id        String   @id @default(uuid())
  status    RequestStatus   @default(pending) 
  createdAt DateTime @default(now())

  // Relations
  conversationId String
  conversation   Conversations @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  userId String
  user   Users  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId]) // Prevent duplicate requests
  @@index([userId])
  @@index([conversationId])
  @@index([status]) // For filtering pending requests
}

enum RequestStatus {
  pending
  accepted
  rejected
}